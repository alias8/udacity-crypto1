import {
  binaryToUnicode,
  oneTimePadDecrypt,
  oneTimePadEncrypt,
  padWithSpaces,
  unicodeToBitsAsString,
  XORStrings,
} from "./utils";
import * as _ from "lodash";

const SPACE_AS_BITS = unicodeToBitsAsString(" ");

const C1 =
  "1010110010011110011111101110011001101100111010001111011101101011101000110010011000000101001110111010010111100100111101001010000011000001010001001001010000000010101001000011100100010011011011011011010111010011000101010111111110010011010111001001010101110001111101010000001011110100000000010010111001111010110000001101010010110101100010011111111011101101001011111001101111101111000100100001000111101111011011001011110011000100011111100001000101111000011101110101110010010100010111101111110011011011001101110111011101100110010100010001100011001010100110001000111100011011001000010101100001110011000000001110001011101111010100101110101000100100010111011000001111001110000011111111111110010111111000011011001010010011100011100001011001101110110001011101011101111110100001111011011000110001011111111101110110101101101001011110110010111101000111011001111";
const C2 =
  "1011110110100110000001101000010111001000110010000110110001101001111101010000101000110100111010000010011001100100111001101010001001010001000011011001010100001100111011010011111100100101000001001001011001110010010100101011111010001110010010101111110001100010100001110000110001111111001000100001001010100011100100001101010101111000100001111101111110111001000101111111101011001010000100100000001011001001010000101001110101110100001111100001011101100100011000110111110001000100010111110110111010010010011101011111111001011011001010010110100100011001010110110001001000100011011001110111010010010010110100110100000111100001111101111010011000100100110011111011001010101000100000011111010010110111001100011100001111100100110010010001111010111011110110001000111101010110101001110111001110111010011111111010100111000100111001011000111101111101100111011001111";
const C1XORC2 = XORStrings(C1, C2);
const M = "the";
const MAsBits = unicodeToBitsAsString(M);

const SIZE = C1.length;

// for (let i = 0; i < C1.length - M.length; i++) {
//   let MPrime = _.padStart(MAsBits, i, SPACE_AS_BITS);
//   MPrime = _.padEnd(MPrime, C1.length, SPACE_AS_BITS);
//   const possibleMessage = XORStrings(MPrime, C1XORC2);
//   const unicode = binaryToUnicode(possibleMessage);
//   let valid = true;
//   for (let j = 0; j < unicode.length; j++) {
//     // if any non latin character encountered
//     if (unicode[j].charCodeAt(0) < 32 || unicode[j].charCodeAt(0) > 126) {
//       valid = false;
//       break;
//     }
//   }
//   if (valid) {
//     console.log(
//       `${i} -----------------------------------------------------------------------`
//     );
//     console.log(unicode);
//   }
//   const a = 2;
// }

const test = () => {
  const key =
    "0100100000011100110111101101101000011100110010000100000011100111111101111111100110100010100110001010110101111100010010000010011110001010100110110111011011100010011000001000010110010010001010100101101010011011100011101101000000010010111011001111101101100101010010101111101101001110111010011010010000111110111010111101001110001000110011111111100010001110100100001101100111000010111011000001101001101011011011100100011001110110000010110001110111001001011101011010111011100101000100100001110000001110011001010110010011100000101010101110100011100001001101010100110010010010111110001100111000001101010101010111111010001111000110110011101001001101101110010001011110100000011110111110001101000001000100101100111001001000100100111001100000011100011001100010100011100110010001111011011011011101111100100011001111110101110101000101100011010001011010010110010";
  const M1 = "hello";
  const M2 = "world";
  const C1 = oneTimePadEncrypt(M1, key);
  const C2 = oneTimePadEncrypt(M2, key);
  const C1XORC2 = XORStrings(C1, C2);
  const wordsToCheck = ["hello", "world"];
  wordsToCheck.forEach((word) => {
    _.range(0, key.length).forEach((index) => {
      const possibleMessage = checkWord(word, index, key, C1XORC2);
      if (checkValid(possibleMessage)) {
        console.log(
          `Possible message: ${possibleMessage}. Word: ${word}. Index: ${index}`
        );
      }
    });
  });

  const b = 2;
};

const checkWord = (
  word: string,
  offset: number,
  key: string,
  C1XORC2: string
) => {
  return binaryToUnicode(
    XORStrings(
      unicodeToBitsAsString(padWithSpaces(word, offset, key.length)),
      C1XORC2
    )
  );
};

const checkValid = (sentence: string): boolean => {
  let valid = true;
  for (let i = 0; i < sentence.length; i++) {
    if (sentence[i].charCodeAt(0) > 126 || sentence[i].charCodeAt(0) < 32) {
      return false;
    }
  }
  return valid;
};

const getCipherText = (M1: string, key: string) => {
  return oneTimePadEncrypt(
    unicodeToBitsAsString(padWithSpaces(M1, 0, key.length)),
    key
  );
};

test();
